import os
import math
from argparse import ArgumentParser

MATRIX_FILE_NAМЕ = "covarianceMatrix.out"

def read_views(file_name: str):
    with open(file_name) as file:
        first_line= file.readline()
        second_line = file.readline().strip()
        array = [float(x) for x in second_line.split("|")]
        return array

def get_triangualar_array(views_path, views):
    array = []
    with open(os.path.join(views_path, MATRIX_FILE_NAМЕ)) as file:
        for line in file:
            tokens = line.strip().split(",")
            view_id = int(tokens[0])
            view_offset = int(tokens[1])
            array.append(views[view_id][view_offset])
    return array

def get_uppper_cell_value(triangular_array, n: int, row_idx: int, col_idx: int):
    if (row_idx == 1) and (col_idx == 1):
        return triagnular_array[0]
    #print("Before row_idx: {} col_idx:{}".format(row_idx, col_idx))
    if (row_idx == 1):
        row_idx = col_idx - 1
        col_idx = row_idx
    else: 
        row_idx = row_idx - 1
    # The part above is used to make mapping possible because 
    # value of triangular matrix are not outputted in the right order
    # They are sorted IF^2 IF * F1 F1^2 F1 * F2 F1 * F3 ... F1 * FN
    #                      IF * F2 F2^2 F2 * F3   ....      F2 * FN
    #                                               IF * FN FN^2
    # When we omit IF^2 and sort data, we get triangular matrix of size n,
    # whose correct column is one in the right, and whose correct row is one 
    # above. 

    idx_cur  = n - row_idx + 1
    idx = int(n * (n + 1) / 2 - idx_cur  * (idx_cur + 1) / 2)
    offset = col_idx - row_idx
    #print("row_idx: {} col_idx:{} idx:{} offset:{}".format(row_idx, col_idx, idx, offset))
    return triagnular_array[idx + offset + 1]

def get_cell_value(triagnular_array, n: int, row: int, col: int):
    if row > col:
        (row, col) = (col, row)
    return get_uppper_cell_value(triagnular_array, n, row, col)

''' 
For usage of this program, user should pass the argument path which represents 
path to data which should appropriate format generated by lmfao.
python3 transform.py -p /home/popina/Documents/dfdb/LMFAO/runtime/cpp/output 
is an example.
It will print the matrix in required format to the output. 
'''
if __name__ == "__main__":

    parser = ArgumentParser()
    parser.add_argument("-p", "--path", dest="path", required=True)

    args = parser.parse_args()
    runtime_path = args.path
    views = {}

    for file_name in os.listdir(runtime_path):
        if file_name.endswith(".tbl"):
            view = read_views(os.path.join(runtime_path, file_name))
            #print(read_views(file_name))
            views[int(file_name.split(".")[0][1:])] = view
    #print(views)

    triagnular_array = get_triangualar_array(runtime_path, views)
    #print (triagnular_array)
    n = int(math.floor(math.sqrt(len(triagnular_array) * 2)))
    print("{0} {0}".format(n))
    for row in range (1, n + 1):
        for col in range(1, n + 1):
            val = get_cell_value(triagnular_array, n, row, col)
            print("{:>2}".format(val), end=" ")
        print()

